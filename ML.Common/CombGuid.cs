using System;
using System.Diagnostics;

namespace ML.Common
{
    public static class CombGuid
    {
        private static Stopwatch perfTimer;
        private static long startTime;

        static CombGuid()
        {
            perfTimer = new Stopwatch();
            startTime = DateTime.UtcNow.Ticks;
            perfTimer.Start();
        }

        private static long GetTicks()
        {
            return startTime + perfTimer.ElapsedTicks;
        }

        //<see cref="http://www.informit.com/articles/article.aspx?p=25862&seqNum=7"/>. 
        /// <summary>
        /// Creates a new sequential guid (aka comb) 
        /// </summary>
        /// <remarks>A comb provides the benefits of a standard Guid w/o the database performance problems.</remarks>  
        /// <returns>A new sequential guid (comb).</returns>
        public static Guid New
        {
            get
            {
                byte[] uid = System.Guid.NewGuid().ToByteArray();
                byte[] binDate = BitConverter.GetBytes(GetTicks()); // use UTC now to prevent conflicts w/ date time savings    
                // create comb in SQL Server sort order 
                byte[] comb = new byte[(uid.Length - 1) + 1];

                // the first 7 bytes are random - if two combs   
                // are generated at the same point in time     
                // they are not guaranteed to be sequential.   
                // But for every DateTime.Tick there are       
                // 72,057,594,037,927,935 unique possibilities so   
                // there shouldn//t be any collisions      
                comb[3] = uid[0];
                comb[2] = uid[1];
                comb[1] = uid[2];
                comb[0] = uid[3];
                comb[5] = uid[4];
                comb[4] = uid[5];
                comb[7] = uid[6];

                // set the first //nibble of the 7th byte to //1100// so    
                // later we can validate it was generated by us    
                comb[6] = (byte)(0xc0 | (15 & uid[7]));

                // the last 8 bytes are sequential,      
                // these will reduce index fragmentation 
                // to a degree as long as there are not a large   
                // number of Combs generated per millisecond      
                comb[9] = binDate[0];
                comb[8] = binDate[1];
                comb[15] = binDate[2];
                comb[14] = binDate[3];
                comb[13] = binDate[4];
                comb[12] = binDate[5];
                comb[11] = binDate[6];
                comb[10] = binDate[7];

                return new System.Guid(comb);

            }
        }

        /// <summary>    
        /// Validates if comb was generated by this class    
        /// </summary>    
        /// <remarks>    
        /// Guids generated by Guid.NewGuid() have a value of    
        /// 0100 for the first 4 bits of the 7th byte. Ours will    
        /// have a value of 1100 for the 6th byte. We//re checking that here.    
        ///     
        /// We could do additional validation by verifying that    
        /// the value of a new Guid is greater than the    
        /// one being validated (or that the last 6 bytes    
        /// resolve to a valid DateTime), but this should    
        /// be enough for now.    
        /// </remarks> 
        public static bool IsValid(Guid value)
        {
            // get the 7th byte      
            byte b = value.ToByteArray()[6];

            // make sure the first //nibble// == 1100        
            return (0xc0 & b) == 0xc0;
        }

        /// <summary>    
        /// Validates Guid to determine the supplied    
        /// value was generated by Comb.NewComb. If    
        /// invalid an ArgumentException is thrown.    
        /// </summary>    
        /// <param name="value"></param>    
        public static void Validate(Guid value)
        {
            if (!IsValid(value))
            {
                throw new ArgumentException("The supplied Id value was not generated by CombGuid.New");

            }
        }
    }
}
